{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>An Omnivector initiative</p> <p></p>"},{"location":"#armasec-documentation","title":"Armasec Documentation","text":"<p>Armasec is a security package that simplifies OIDC security for FastAPI apps.</p>"},{"location":"#overview","title":"Overview","text":"<p>Adding a security layer on top of your API can be difficult, especially when working with an OIDC platform. It's hard enough to get your OIDC provider configured correctly. Armasec aims to take the pain out of securing your APIs routes.</p> <p>Armasec is an opinionated library that attemtps to use the most obvious and commonly used workflows when working with OIDC and making configuration as simple as possible.</p> <p>When using the Armasec helper class, you only need two configuration settings to get going:</p> <ol> <li>Domain: the domain of your OIDC provider</li> <li>Audience: An optional setting that restricts tokens to those intended for your API.</li> </ol> <p>That's it! Once you have those settings dialed in, you can just worry about checking the permissions scopes of your endpoints</p>"},{"location":"#inception","title":"Inception","text":"<p>Armasec was originally developed as an internal tool to add security in tandem with Auth0. Since its inception, Armasec has been used in production with both Auth0 and Keycloak. It should work with other OIDC providers, assuming they are configured correctly, but the developers of Armasec make no guarantees for other platforms.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> </ul>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>The <code>armasec</code> package can be installed like any other python package. It is available on PyPI</p>"},{"location":"getting_started/#poetry","title":"Poetry","text":"<p>To install via <code>poetry</code>, simply run:</p> <pre><code>poetry add armasec\n</code></pre>"},{"location":"getting_started/#pip","title":"Pip","text":"<p>To install directly with <code>pip</code>, simply run:</p> <pre><code>pip install armasec\n</code></pre>"},{"location":"minimal_example/","title":"Minimal Example","text":"<p>The following is a minimal example of how to configure your API to enforce security on endpoints using tokens issued by Auth0.</p> <p>First, create a file named <code>example.py</code> with the following contents:</p> example.py<pre><code>import os\nfrom armasec import Armasec\nfrom fastapi import FastAPI, Depends\napp = FastAPI()\narmasec = Armasec(\ndomain=os.environ.get(\"ARMASEC_DOMAIN\"),\naudience=os.environ.get(\"ARMASEC_AUDIENCE\"),\n)\n@app.get(\"/stuff\", dependencies=[Depends(armasec.lockdown(\"read:stuff\"))])\nasync def check_access():\nreturn dict(message=\"Successfully authenticated!\")\n</code></pre> <p>In this example, you would have set two environment variables for your project settings:</p> <ul> <li><code>ARMASEC_DOMAIN</code></li> <li>This would be your Auth0 domain</li> <li>Example: <code>my-auth.us.auth0.com</code></li> <li><code>ARMASEC_AUDIENCE</code></li> <li>You get this from your Auth0 API App</li> <li>Example: <code>https://my-api.my-domain.com</code></li> </ul> <p>When you run your app, access to the <code>/stuff</code> endpoint would be restricted to authenticated users whose access tokens carried the permission scope \"read:stuff\".</p> <p>For a step-by-step walk-through of how to set up Auth0 for the minimal example, see the \"Getting Started with Auth0\" page.</p> <p>The above code can be found in examples/basic.py.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#armasec.armasec","title":"armasec.armasec","text":"<p>This module defines the core Armasec class.</p>"},{"location":"reference/#armasec.armasec.Armasec","title":"Armasec","text":"<p>This is a factory class for TokenSecurity. It allows the machinery of armasec to be initialized correctly so that the factory method <code>lockdown</code> can initialize new instances of TokenSecurity to protect routes. It's not essential to use Armasec to secure routes, but it cuts down on the boilerplate necessary to do so.</p>"},{"location":"reference/#armasec.armasec.Armasec.__init__","title":"__init__","text":"<pre><code>__init__(domain_configs: Optional[List[DomainConfig]] = None, debug_logger: Optional[Callable[[str], None]] = noop, debug_exceptions: bool = False, **kargs: bool)\n</code></pre> <p>Stores initialization values for the TokenSecurity. All are passed through.</p> <p>Parameters:</p> Name Type Description Default <code>domain_configs</code> <code>Optional[List[DomainConfig]]</code> <p>List of domain configuration to authenticate the tokens against.</p> <code>None</code> <code>debug_logger</code> <code>Optional[Callable[[str], None]]</code> <p>A callable, that if provided, will allow debug logging. Should be               passed as a logger method like <code>logger.debug</code></p> <code>noop</code> <code>debug_exceptions</code> <code>bool</code> <p>If True, raise original exceptions. Should only be used in a testing               or debugging context.</p> <code>False</code> <code>kargs</code> <p>Arguments compatible to instantiate the DomainConfig model.</p> <code>{}</code>"},{"location":"reference/#armasec.armasec.Armasec.lockdown","title":"lockdown  <code>cached</code>","text":"<pre><code>lockdown(*scopes: str, permission_mode: PermissionMode = PermissionMode.ALL) -&gt; TokenSecurity\n</code></pre> <p>Initialize an instance of TokenSecurity to lockdown a route. Uses memoization to minimize the number of TokenSecurity instances initialized. Applies supplied permission_mode when checking token permssions against TokenSecurity scopes.</p> <p>Parameters:</p> Name Type Description Default <code>scopes</code> <code>str</code> <p>A list of scopes needed to access the endpoint.</p> <code>()</code> <code>permissions_mode</code> <p>If \"ALL\", all scopes listed are required for access. If \"SOME\", only one of the scopes listed are required for access.</p> required"},{"location":"reference/#armasec.armasec.Armasec.lockdown_all","title":"lockdown_all","text":"<pre><code>lockdown_all(*scopes: str) -&gt; TokenSecurity\n</code></pre> <p>Initialize an instance of TokenSecurity to lockdown a route. Uses memoization to minimize the number of TokenSecurity instances initialized. Requires all the scopes in the TokenSecurity instance to be included in the token permissions. This is just a wrapper around <code>lockdown()</code> with default permission_mode and is only included for symmetry.</p> <p>Parameters:</p> Name Type Description Default <code>scopes</code> <code>str</code> <p>A list of the scopes needed to access the endpoint. All are required.</p> <code>()</code>"},{"location":"reference/#armasec.armasec.Armasec.lockdown_some","title":"lockdown_some","text":"<pre><code>lockdown_some(*scopes: str) -&gt; TokenSecurity\n</code></pre> <p>Initialize an instance of TokenSecurity to lockdown a route. Uses memoization to minimize the number of TokenSecurity instances initialized. Requires at least one permission in the token to match a scope attached to the TokenSecurity instance.</p> <p>Parameters:</p> Name Type Description Default <code>scopes</code> <code>str</code> <p>A list of the scopes needed to access the endpoint. Only one is required.</p> <code>()</code>"},{"location":"reference/#armasec.exceptions","title":"armasec.exceptions","text":""},{"location":"reference/#armasec.exceptions.ArmasecError","title":"ArmasecError","text":"<p>             Bases: <code>Buzz</code></p> <p>A custom exception class used for checking conditions and handling other exceptions.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>int</code> <p>The HTTP status code indicated by the error. Set to 400.</p>"},{"location":"reference/#armasec.exceptions.AuthenticationError","title":"AuthenticationError","text":"<p>             Bases: <code>ArmasecError</code></p> <p>Indicates a failure to authenticate and decode jwt.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>int</code> <p>The HTTP status code indicated by the error. Set to 401.</p>"},{"location":"reference/#armasec.exceptions.AuthorizationError","title":"AuthorizationError","text":"<p>             Bases: <code>ArmasecError</code></p> <p>Indicates that the provided claims don't match the claims required for a protected endpoint.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>int</code> <p>The HTTP status code indicated by the error. Set to 403.</p>"},{"location":"reference/#armasec.exceptions.PayloadMappingError","title":"PayloadMappingError","text":"<p>             Bases: <code>ArmasecError</code></p> <p>Indicates that the configured payload_claim_mapping did not match a path in the token.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>int</code> <p>The HTTP status code indicated by the error. Set to 500.</p>"},{"location":"reference/#armasec.openid_config_loader","title":"armasec.openid_config_loader","text":"<p>This module provides the OpenidConfigLoader which is used to load openid-configuration data from an OIDC provider.</p>"},{"location":"reference/#armasec.openid_config_loader.OpenidConfigLoader","title":"OpenidConfigLoader","text":""},{"location":"reference/#armasec.openid_config_loader.OpenidConfigLoader.config","title":"config  <code>property</code>","text":"<pre><code>config: OpenidConfig\n</code></pre> <p>Retrive the openid config from an OIDC provider. Lazy loads the config so that API calls are deferred until the coniguration is needed.</p>"},{"location":"reference/#armasec.openid_config_loader.OpenidConfigLoader.jwks","title":"jwks  <code>property</code>","text":"<pre><code>jwks: JWKs\n</code></pre> <p>Retrives JWKs public keys from an OIDC provider. Lazy loads the jwks so that API calls are deferred until the jwks are needed.</p>"},{"location":"reference/#armasec.openid_config_loader.OpenidConfigLoader.__init__","title":"__init__","text":"<pre><code>__init__(domain: str, use_https: bool = True, debug_logger: Optional[Callable[..., None]] = None)\n</code></pre> <p>Initializes a base TokenManager.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <p>The secret key needed to decode a token</p> required <code>domain</code> <code>str</code> <p>The domain of the OIDC provider. This is to construct the            openid-configuration url</p> required <code>use_https</code> <code>bool</code> <p>If falsey, use <code>http</code> instead of <code>https</code> (the default).</p> <code>True</code> <code>debug_logger</code> <code>Optional[Callable[..., None]]</code> <p>A callable, that if provided, will allow debug logging. Should be passed            as a logger method like <code>logger.debug</code></p> <code>None</code>"},{"location":"reference/#armasec.openid_config_loader.OpenidConfigLoader.build_openid_config_url","title":"build_openid_config_url  <code>staticmethod</code>","text":"<pre><code>build_openid_config_url(domain: str, use_https: bool = True)\n</code></pre> <p>Builds a url for an openid configuration given a domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The domain of the OIDC provider for which to build a URL</p> required <code>use_https</code> <code>bool</code> <p>Use <code>https</code> for the URL by default. If falsey, use <code>http</code> instead.</p> <code>True</code>"},{"location":"reference/#armasec.pytest_extension","title":"armasec.pytest_extension","text":"<p>This module provides a pytest plugin for testing.</p>"},{"location":"reference/#armasec.pytest_extension.build_mock_openid_server","title":"build_mock_openid_server","text":"<pre><code>build_mock_openid_server(domain, openid_config, jwk, jwks_uri) -&gt; Callable[[str, OpenidConfig, JWK, str], _GeneratorContextManager]\n</code></pre> <p>Provide a fixture that returns a context manager that mocks opend-config routes.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <p>The domain of the openid server to mock.</p> required <code>openid_config</code> <p>The config to return from the mocked config route.</p> required <code>jwk</code> <p>The jwk to return from the mocked jwk route.</p> required <code>jwks_uri</code> <p>The URL of the jwks route to mock.</p> required <p>Returns:</p> Type Description <code>Callable[[str, OpenidConfig, JWK, str], _GeneratorContextManager]</code> <p>A context manager that, while active, mocks the openid routes needed by Armasec.</p>"},{"location":"reference/#armasec.pytest_extension.build_rs256_token","title":"build_rs256_token","text":"<pre><code>build_rs256_token(rs256_private_key, rs256_iss, rs256_sub, rs256_kid)\n</code></pre> <p>Provide a fixture that returns a helper method that can build a JWT.</p> <p>The JWT is signed with the private key provided by the rs256_private_key.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_private_key</code> <p>An implicit fixture parameter.</p> required <code>rs256_iss</code> <p>An implicit fixture parameter.</p> required <code>rs256_sub</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.mock_openid_server","title":"mock_openid_server","text":"<pre><code>mock_openid_server(rs256_domain, rs256_openid_config, rs256_jwk, rs256_jwks_uri)\n</code></pre> <p>Provide a fixture that mocks an openid server using the extension fixtures.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_domain</code> <p>An implicit fixture parameter.</p> required <code>rs256_openid_config</code> <p>An implicit fixture parameter.</p> required <code>rs256_jwk</code> <p>An implicit fixture parameter.</p> required <code>rs256_jwks_uri</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.rs256_domain","title":"rs256_domain","text":"<pre><code>rs256_domain()\n</code></pre> <p>Provide a fixture that returns a domain for use in other fixtures.</p> <p>The value here doesn't really have anything to do with an actual domain name.</p>"},{"location":"reference/#armasec.pytest_extension.rs256_domain_config","title":"rs256_domain_config","text":"<pre><code>rs256_domain_config(rs256_domain)\n</code></pre> <p>Provide a fixture that returns the DomainConfig model for the default rs256 domain.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_domain</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.rs256_iss","title":"rs256_iss","text":"<pre><code>rs256_iss(rs256_domain)\n</code></pre> <p>Provide a fixture that returns an issuer claim for use in other fixtures.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_domain</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.rs256_jwk","title":"rs256_jwk","text":"<pre><code>rs256_jwk(rs256_kid)\n</code></pre> <p>Provide a fixture that returns a JWK for use in other fixtures.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_kid</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.rs256_jwks_uri","title":"rs256_jwks_uri","text":"<pre><code>rs256_jwks_uri(rs256_domain)\n</code></pre> <p>Provide a fixture that returns a jwks uri for use in other fixtures.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_jwks_uri</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.rs256_kid","title":"rs256_kid","text":"<pre><code>rs256_kid()\n</code></pre> <p>Provide a fixture that returns a KID header value for use in other fixtures.</p>"},{"location":"reference/#armasec.pytest_extension.rs256_openid_config","title":"rs256_openid_config","text":"<pre><code>rs256_openid_config(rs256_iss, rs256_jwks_uri)\n</code></pre> <p>Provide a fixture that returns an openid configuration for use in other fixtures.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_iss</code> <p>An implicit fixture parameter.</p> required <code>rs256_jwks_uri</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.rs256_private_key","title":"rs256_private_key","text":"<pre><code>rs256_private_key()\n</code></pre> <p>Provide a fixture that returns a pre-generated private key for RS256 hashing in other fixtures.</p>"},{"location":"reference/#armasec.pytest_extension.rs256_public_key","title":"rs256_public_key","text":"<pre><code>rs256_public_key()\n</code></pre> <p>Provide a fixture that returns a pre-generated public key for RS256 hashing in other fixtures.</p>"},{"location":"reference/#armasec.pytest_extension.rs256_sub","title":"rs256_sub","text":"<pre><code>rs256_sub()\n</code></pre> <p>Provide a fixture that returns a sum claim for use in other fixtures.</p>"},{"location":"reference/#armasec.token_decoder","title":"armasec.token_decoder","text":"<p>This module provides an abstract base class for algorithmic token decoders</p>"},{"location":"reference/#armasec.token_decoder.TokenDecoder","title":"TokenDecoder","text":"<p>Decoder class used to decode tokens given an algorithm and jwks.</p>"},{"location":"reference/#armasec.token_decoder.TokenDecoder.__init__","title":"__init__","text":"<pre><code>__init__(jwks: JWKs, algorithm: str = 'RS256', debug_logger: Callable[..., None] | None = None, decode_options_override: dict | None = None, payload_claim_mapping: dict | None = None)\n</code></pre> <p>Initializes a TokenDecoder.</p> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>str</code> <p>The algorithm to use for decoding. Defaults to RS256.</p> <code>'RS256'</code> <code>jwks</code> <code>JWKs</code> <p>JSON web keys object holding the public keys for decoding.</p> required <code>openid_config</code> <p>The openid_configuration needed for claims such as 'issuer'.</p> required <code>debug_logger</code> <code>Callable[..., None] | None</code> <p>A callable, that if provided, will allow debug logging. Should                      be passed as a logger method like <code>logger.debug</code></p> <code>None</code> <code>decode_options_override</code> <code>dict | None</code> <p>Options that can override the default behavior of the jwt                      decode method. For example, one can ignore token expiration by                      setting this to <code>{ \"verify_exp\": False }</code></p> <code>None</code> <code>payload_claim_mapping</code> <code>dict | None</code> <p>Optional mappings that are applied to map claims to top-level                      attribute of TokenPayload using a dict format of:</p> <pre><code>                 ```\n                 {\n                     \"top_level+attribute\": \"decoded.token.JMESPath\"\n                 }\n                 ```\n                 The values _must_ be a valid JMESPath.\n\n                 Consider this example:\n\n                 ```\n                 {\n                      \"permissions\": \"resource_access.default.roles\"\n                 }\n                 ```\n\n                 The above example would result in a TokenPayload like:\n\n                 ```\n                 TokenPayload(permissions=token[\"resource_access\"][\"default\"][\"roles\"])\n                 ```\n                 Raises a 500 if the path does not match\n</code></pre> <code>None</code>"},{"location":"reference/#armasec.token_decoder.TokenDecoder.decode","title":"decode","text":"<pre><code>decode(token: str, **claims: str) -&gt; TokenPayload\n</code></pre> <p>Decode a JWT into a TokenPayload while checking signatures and claims.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The token to decode.</p> required <code>claims</code> <p>Additional claims to verify in the token.</p> <code>{}</code>"},{"location":"reference/#armasec.token_decoder.TokenDecoder.get_decode_key","title":"get_decode_key","text":"<pre><code>get_decode_key(token: str) -&gt; dict\n</code></pre> <p>Search for a public keys within the JWKs that matches the incoming token.</p> <p>Compares the token's unverified header against available JWKs. Uses the matching JWK for the decode key.  Raise AuthenticationError if matching public key cannot be found.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The token to match against available JWKs.</p> required"},{"location":"reference/#armasec.token_manager","title":"armasec.token_manager","text":"<p>This module defines a TokenManager that can be used to extract token payloads from request headers.</p>"},{"location":"reference/#armasec.token_manager.TokenManager","title":"TokenManager","text":"<p>Handle auth via a TokenDecoder and manage extraction from request headers and serialization into TokenPayload instances.</p>"},{"location":"reference/#armasec.token_manager.TokenManager.__init__","title":"__init__","text":"<pre><code>__init__(openid_config: OpenidConfig, token_decoder: TokenDecoder, audience: Optional[str] = None, debug_logger: Optional[Callable[..., None]] = None, decode_options_override: Optional[dict] = None)\n</code></pre> <p>Initialize a base TokenManager.</p> <p>Parameters:</p> Name Type Description Default <code>openid_config</code> <code>OpenidConfig</code> <p>The openid_configuration needed for claims such as 'issuer'.</p> required <code>token_decoder</code> <code>TokenDecoder</code> <p>The decoder used to verify jwts</p> required <code>audience</code> <code>Optional[str]</code> <p>An optional audience to check in decoded tokens.</p> <code>None</code> <code>debug_logger</code> <code>Optional[Callable[..., None]]</code> <p>A callable, that if provided, will allow debug logging. Should                      be passed as a logger method like <code>logger.debug</code></p> <code>None</code> <code>decode_options_override</code> <code>Optional[dict]</code> <p>Options that can override the default behavior of the jwt                      decode method. For example, one can ignore token expiration by                      setting this to <code>{ \"verify_exp\": False }</code></p> <code>None</code>"},{"location":"reference/#armasec.token_manager.TokenManager.extract_token_payload","title":"extract_token_payload","text":"<pre><code>extract_token_payload(headers: Union[Headers, dict]) -&gt; TokenPayload\n</code></pre> <p>Retrieve a token from a request header and decode it into a TokenPayload.</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Union[Headers, dict]</code> <p>The headers from which to retrieve a JWT.</p> required"},{"location":"reference/#armasec.token_manager.TokenManager.unpack_token_from_header","title":"unpack_token_from_header","text":"<pre><code>unpack_token_from_header(headers: Union[Headers, dict]) -&gt; str\n</code></pre> <p>Unpack a JWT from a request header.</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Union[Headers, dict]</code> <p>The headers from which to unpack a JWT.</p> required"},{"location":"reference/#armasec.token_payload","title":"armasec.token_payload","text":"<p>This module defines a pydantic schema for the payload of a jwt.</p>"},{"location":"reference/#armasec.token_payload.TokenPayload","title":"TokenPayload","text":"<p>             Bases: <code>BaseModel</code></p> <p>A convenience class that can be used to access parts of a decoded jwt.</p> <p>Attributes:</p> Name Type Description <code>sub</code> <code>str</code> <p>The \"sub\" claim from a JWT.</p> <code>permissions</code> <code>List[str]</code> <p>The permissions claims extracted from a JWT.</p> <code>expire</code> <code>datetime</code> <p>The \"exp\" claim extracted from a JWT.</p> <code>client_id</code> <code>str</code> <p>The \"azp\" claim extracted from a JWT.</p>"},{"location":"reference/#armasec.token_payload.TokenPayload.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert a TokenPayload to the equivalent dictionary returned by <code>jwt.decode()</code>.</p>"},{"location":"reference/#armasec.token_security","title":"armasec.token_security","text":"<p>This module defines a TokenSecurity injectable that can be used enforce access on FastAPI routes.</p>"},{"location":"reference/#armasec.token_security.ManagerConfig","title":"ManagerConfig","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model class to represent a TokenManager instance and its domain configuration for easier mapping</p> <p>Attributes:</p> Name Type Description <code>manager</code> <code>TokenManager</code> <p>The TokenManager instance to use for decoding tokens.</p> <code>domain_config</code> <code>DomainConfig</code> <p>The DomainConfig for the openid server.</p>"},{"location":"reference/#armasec.token_security.PermissionMode","title":"PermissionMode","text":"<p>             Bases: <code>AutoNameEnum</code></p> <p>Endpoint permissions.</p> <p>Attributes:</p> Name Type Description <code>ALL</code> <p>Require all listed permissions.</p> <code>SOME</code> <p>Require at least one of the listed permissions.</p>"},{"location":"reference/#armasec.token_security.TokenSecurity","title":"TokenSecurity","text":"<p>             Bases: <code>APIKeyBase</code></p> <p>An injectable Security class that returns a TokenPayload when used with Depends().</p> <p>Attributes:</p> Name Type Description <code>manager</code> <code>Optional[TokenManager]</code> <p>The TokenManager to use for token validation and extraction.</p>"},{"location":"reference/#armasec.token_security.TokenSecurity.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(request: Request) -&gt; TokenPayload\n</code></pre> <p>This method is called by FastAPI's dependency injection system when a TokenSecurity instance is injected to a route endpoint via the Depends() method. Lazily loads the OIDC config, the TokenDecoder, and the TokenManager if they are not already initialized.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request to check for secure access.</p> required"},{"location":"reference/#armasec.token_security.TokenSecurity.__init__","title":"__init__","text":"<pre><code>__init__(domain_configs: List[DomainConfig], scopes: Optional[Iterable[str]] = None, permission_mode: PermissionMode = PermissionMode.ALL, debug_logger: Optional[Callable[..., None]] = None, debug_exceptions: bool = False)\n</code></pre> <p>Initializes the TokenSecurity instance.</p> <p>Parameters:</p> Name Type Description Default <code>domain_configs</code> <code>List[DomainConfig]</code> <p>List of domain configuration to authenticate the tokens against.</p> required <code>scopes</code> <code>Optional[Iterable[str]]</code> <p>Optional permissions scopes that should be checked</p> <code>None</code> <code>permission_mode</code> <code>PermissionMode</code> <p>The PermissionMode to apply in the protected route.</p> <code>ALL</code> <code>debug_logger</code> <code>Optional[Callable[..., None]]</code> <p>A callable, that if provided, will allow debug logging. Should be               passed as a logger method like <code>logger.debug</code></p> <code>None</code> <code>debug_exceptions</code> <code>bool</code> <p>If True, raise original exceptions. Should only be used in a testing               or debugging context.</p> <code>False</code>"},{"location":"reference/#armasec.utilities","title":"armasec.utilities","text":"<p>Provides some utility functions.</p>"},{"location":"reference/#armasec.utilities.log_error","title":"log_error","text":"<pre><code>log_error(logger: Callable[..., None], dep: DoExceptParams)\n</code></pre> <p>Logs an en error with the supplied message, a string representation of the error, and its traceback. If the logger supplied is noop, do nothing. Pass as a partial when using the Buzz <code>handle_errors</code> context manager::</p> <pre><code>with Buzz.handle_errors(\"Boom!\", do_except=partial(log_error, debug_logger)):\n    do_some_risky_stuff()\n</code></pre>"},{"location":"reference/#armasec.utilities.noop","title":"noop","text":"<pre><code>noop(*args, **kwargs)\n</code></pre> <p>This is a no-op function that...does nothing.</p>"},{"location":"reference/#armasec.schemas.armasec_config","title":"armasec.schemas.armasec_config","text":"<p>This module provides a pydantic schema describing Armasec's configuration parameters.</p>"},{"location":"reference/#armasec.schemas.armasec_config.DomainConfig","title":"DomainConfig","text":"<p>             Bases: <code>BaseModel</code></p> <p>This model provides a specification for the input domains to authenticate against. It expects the domain indeed and the audience to refer to.</p> <p>Attributes:</p> Name Type Description <code>domain</code> <code>str</code> <p>The OIDC domain from which resources are loaded.</p> <code>audience</code> <code>Optional[str]</code> <p>Optional designation of the token audience.</p> <code>algorithm</code> <code>str</code> <p>The Algorithm to use for decoding. Defaults to RS256.</p> <code>use_https</code> <code>bool</code> <p>If true, use <code>https</code> for URLs. Otherwise use <code>http</code></p> <code>match_keys</code> <code>Dict[str, Union[str, List[Any], Dict[Any, Any], Set[Any], bool, int, float]]</code> <p>Dictionary of k/v pairs to match in the token when decoding it.</p>"},{"location":"reference/#armasec.schemas.jwks","title":"armasec.schemas.jwks","text":"<p>This module provides pydantic schemas for JSON Web Keys.</p>"},{"location":"reference/#armasec.schemas.jwks.JWK","title":"JWK","text":"<p>             Bases: <code>BaseModel</code></p> <p>This Model provides a specification for the objects retrieved from JWK endpoints in OIDC providers. It also assists with validation and item access.</p> <p>Attributes:</p> Name Type Description <code>alg</code> <code>str</code> <p>The algorithm to use for hash validation.</p> <code>e</code> <code>str</code> <p>The exponent parameter to use in RS256 hashing</p> <code>kid</code> <code>str</code> <p>The \"kid\" claim to uniquely identify the key.</p> <code>kty</code> <code>str</code> <p>The \"kty\" claim to identify the type of the key.</p> <code>n</code> <code>str</code> <p>The modulus parameter to use in RS256 hashing.</p> <code>use</code> <code>Optional[str]</code> <p>The claim that identifies the intended use of the public key.</p> <code>x5c</code> <code>Optional[List[str]]</code> <p>The X.509 certificate chain parameter</p> <code>x5c</code> <code>Optional[List[str]]</code> <p>The X.509 certificate SHA-1 thumbprint parameter</p>"},{"location":"reference/#armasec.schemas.jwks.JWKs","title":"JWKs","text":"<p>             Bases: <code>BaseModel</code></p> <p>This Model provides a specification for the container object retrieved from JWK endpoints in OIDC providers. It also assists with validation and item access.</p> <p>Attributes:</p> Name Type Description <code>keys</code> <code>List[JWK]</code> <p>The list of JWKs contained within.</p>"},{"location":"reference/#armasec.schemas.openid_config","title":"armasec.schemas.openid_config","text":"<p>This module provides a pydantic schema describing openid-configuration data.</p>"},{"location":"reference/#armasec.schemas.openid_config.OpenidConfig","title":"OpenidConfig","text":"<p>             Bases: <code>BaseModel</code></p> <p>Provides a specification for the objects retrieved from openid_configuration endpoint of the OIDC providers. Only includes needed fields for supported Manager instances. Assists with validation and item access.</p> <p>Attributes:</p> Name Type Description <code>issuer</code> <code>AnyHttpUrl</code> <p>The URL of the issuer of the tokens.</p> <code>jwks_uri</code> <code>AnyHttpUrl</code> <p>The URI where JWKs can be foun don the OpenID server.</p>"},{"location":"tutorials/getting_started_with_auth0/","title":"Getting started with Auth0","text":"<p>This step-by-step walk-through will show you how to get an Auth0 account set up for use with the minimal example.</p> <p>You will need:</p> <ul> <li>Python 3.8+ installed</li> <li>Python packages <code>armasec</code> and <code>uvicorn</code> installed</li> </ul>"},{"location":"tutorials/getting_started_with_auth0/#create-auth0-account-tenant","title":"Create Auth0 account tenant","text":"<p>Navigate to Auth0's homepage, and click <code>Sign Up</code>.</p> <p>Create a new account (if you don't already have one). It doesn't really matter how you choose to sign up, but I used my google account.</p> <p> Create a personal account</p> <p>For this tutorial, just select a \"Personal\" account. You can come back and repeat the process for your company later if you need to.</p> <p>Select <code>I need advanced settings</code> so that you can choose your tenant name, and click <code>Next</code> to move on to tenant setup.</p> <p> Select tenant domain</p> <p>Select your tenant domain. For this tutorial, I will be using \"armasec-tutorial\". Choose your region and click <code>Create Account</code>. The full domain that I will use later is \"armasec-tutorial.us.auth0.com\".</p>"},{"location":"tutorials/getting_started_with_auth0/#add-your-api-application","title":"Add your API application","text":"<p>This will set up the Auth0 api endpoints that Auth0 will use to authenticate your users.</p> <p> Navigate to Applications &gt; APIs</p> <p>Click <code>Applications</code> -&gt; <code>APIs</code></p> <p> Create an API</p> <p>Click <code>Create API</code></p> <p> Fill out API form</p> <p>Fill out the form. The Name you choose doesn't matter, but for the tutorial, I used \"Armasec Tutorial\".  Choose a name for the identifier that makes sense, as this will be the \"Audience\" for your tutorial app. I chose \"https://armasec-tutorial.com\" for this tutorial.</p> <p>Leave the \"Signing Algorithm\" as \"RS256\". Armasec also supports HS256, but it is not preferred.</p> <p>Click <code>Create</code></p> <p> Enable RBAC Settings</p> <p>Go to the Settings tab and scroll down to the \"RBAC Settings\"</p> <p>Activate <code>Enable RBAC</code> and <code>Add Permissions</code> in the Access Token\".</p> <p>This will include permissions scopes to your users' access tokens.</p> <p>Click <code>Save</code></p>"},{"location":"tutorials/getting_started_with_auth0/#add-your-permissions","title":"Add your permissions","text":"<p>Next, we will add the permission for the minimal example.</p> <p> Add a permission</p> <p>Click on the <code>Permissions</code> tab and add the \"read:stuff\" permission.</p>"},{"location":"tutorials/getting_started_with_auth0/#grant-your-permission-to-the-test-app","title":"Grant your permission to the test app","text":"<p>Auth0 provides a \"Machine-to-Machine\" test app for verifying that log in will work. We will grant our \"read:stuff\" permission to tokens provided from this app.</p> <p> Navigate to Applications</p> <p>Navigate to <code>Applications</code> -&gt; <code>Applications</code></p> <p> Select tutorial test app</p> <p>Click on <code>Armasec Tutorial (Test Application)</code></p> <p> Add permission to test app</p> <p>Go to the APIs tab and click the drop-down. Select the \"read-stuff\" box in the \"Permissions\" box. Click <code>Update</code>.</p>"},{"location":"tutorials/getting_started_with_auth0/#start-up-the-example-app","title":"Start up the example app","text":"<p>Copy the example app to a local source file called \"example.py\".</p> <p>Start it up with uvicorn:</p> <pre><code>python -m uvicorn --host 0.0.0.0 example:app\n</code></pre>"},{"location":"tutorials/getting_started_with_auth0/#try-it-out","title":"Try it out","text":"<p>Next, we will try to use a test token to call our minimal example's endpoint.</p> <p>Navigate back to <code>Applications</code> -&gt; <code>APIs</code>, select the <code>Armasec Tutorial</code>, and go to the Test tab.</p> <p> Copy test access token</p> <p>Find the \"Response\" box. This contains a token that has been issued by your test application. Click the <code>Copy Token</code> button.</p> <p>Now, open a browser to \"localhost:8000/docs\"</p> <p> Swagger page for example</p> <p>This will show you the auto-generated swagger docs for the example API app. Click on the <code>Authorize</code> button to add the token you copied to the clipboard in the header of requests to the API.</p> <p> Add access token in Swagger</p> <p>First, type \"Bearer \" followed by pasting the token from the clipboard into the form and click the <code>Authorize</code> button in the dialog, click <code>Close</code> to dismiss the dialog. Now, all subsequent calls to the API will include a header that looks like:</p> <pre><code>{\n\"Authorization\": \"Bearer eyJhbGciOi...\"\n}\n</code></pre> <p>Now, expand the \"GET\" REST operation on the <code>/stuff</code> endpoint and click <code>Try it out</code>.</p> <p> Try it out</p> <p>Finally, click <code>Execute</code> to issue the request to the API.</p> <p> Execute</p> <p>You should see a response that includes a 200 status code and a response body that includes:</p> <pre><code>{\n\"message\": \"Successfully authenticated\"\n}\n</code></pre> <p>Congratulations! You are now using Armasec and Auth0 to authorize requests to your API.</p>"},{"location":"tutorials/getting_started_with_auth0/#tinker","title":"Tinker","text":"<p>Now, there are a few things you can do to check out how things work. Try the following things:</p> <ul> <li>Remove the \"read:stuff\" permission from the test application and try another request</li> <li>Try a request without being authorized in swagger</li> <li>Try making requests using <code>curl</code> or the <code>httpx</code> library in IPython</li> </ul>"},{"location":"tutorials/getting_started_with_auth0/#send-feedback","title":"Send feedback","text":"<p>If the above tutorial didn't work as expected, a step needs better clarification, or you have some questions about it, please create an issue on Armasec's GitHub's issues.</p>"},{"location":"tutorials/getting_started_with_keycloak/","title":"Getting started with Keycloak","text":"<p>This step-by-step walk-through will show you how to get your Keycloak server set up to work with the minimal example. For this tutorial, I am running Keycloak locally with Docker.</p> <p>You will need:</p> <ul> <li>Docker installed (or an existing Keycloak server)</li> <li>Python 3.8+ installed</li> </ul>"},{"location":"tutorials/getting_started_with_keycloak/#installing-python-packages","title":"Installing python packages","text":"<p>The first thing you will need to do is to install some neeeded python dependencies. In order to run the example API, you will need the the <code>uvicorn</code> package installed. You will also be using the Armasec CLI to verify that you can log in. For this, you will need the <code>armasec</code> package with the <code>cli</code> extra. For this tutorial, it will be best to work in a new virtual environment. To bootstrap it, run the following commands:</p> <pre><code>python -m venv env\nsource env/bin/activate\npip install uvicorn armasec[cli]\n</code></pre> <p>When the commands finish running, your environment will be ready to complete this guide.</p>"},{"location":"tutorials/getting_started_with_keycloak/#start-your-keycloak-server","title":"Start your Keycloak server","text":"<p>If you want to try the example locally without an existing Keycloak server, you will need to start a new one. Docker is the easiest way to get Keycloak up and running. To start the Keycloak server in Docker, run the following command:</p> <pre><code>docker run -p 8080:8080 -e KEYCLOAK_ADMIN=\"admin\" -e KEYCLOAK_ADMIN_PASSWORD=\"admin\" keycloak/keycloak:22.0.5 start-dev\n</code></pre> <p>This will start a new Keycloak server with an admin UI available at localhost:8080. A new <code>admin</code> user will automatically be created with the password \"admin\".</p> <p>Open a browser and load the address <code>localhost:8080</code>. Then, click on the \"Administration Console\" to log in.</p> <p> Log-in to admin console</p> <p>The sign-in credentials for the admin account are:</p> Field Value Username admin Password admin <p>After you log in, the UI will automatically load the \"Master\" realm.</p>"},{"location":"tutorials/getting_started_with_keycloak/#set-up-your-master-realm","title":"Set up your \"Master\" realm","text":"<p>First, you should change the lifespan for tokens. By default they expire after 1 minute, but that's not so friendly for a tutorial, so you should lengthen the lifespan to 15 minutes.</p> <p>Click on the \"Realm settings\" section in the side-nav, and then go to the \"Tokens\" tab. Find the \"Access Token Lifespan\" setting, and change it to 15 minutes.</p> <p> Realm settings</p> <p>Click \"Save\" at the bottom after you change the value. All of the rest of the settings can be left as they are.</p>"},{"location":"tutorials/getting_started_with_keycloak/#set-up-a-client","title":"Set up a client","text":"<p>You will need a client that is configured for the tutorial. To do this, navigate to the \"Clients\" tab in the nav bar and click the \"Create client\" button in the \"Clients list\" tab:</p> <p> Create the client</p> <p>A creation wizard will load starting with the \"General Settings\" tab. For this tutorial, use the name \"armasec_tutorial\". Click the \"Next\" button to go on to the next page.</p> <p> Name the client</p> <p>In the \"Capability config\" page, select the \"OAuth 2.0 Device Authorization Grant\" setting. This will be needed to log in via the Armasec CLI later. Click the \"Next\" button to go on to the next page.</p> <p> Device auth</p> <p>Finally, in the \"Login settings\" page, put \"*\" in the \"Valid redirect URIs\" setting. Click the \"Save\" button to finish creating the new client.</p> <p> Redirect URIs</p> <p>Once the new client is created, you will be redirected to the \"Client details\" page.</p> <p>This tutorial demonstrates how to set up role-based access on an API endpoint. So, the next step is to create a role that the API will require users to have in order to access an endpoint.</p> <p>Click on the \"Roles\" tab of the \"Client Details\" page, and then click the \"Create role\" button.</p> <p> Create Role</p> <p>The name is not important as long as it matches on your API endpoint. For this tutorial, name the role \"read:stuff\" and then click the \"Save\" button.</p> <p> Name Role</p> <p>The final step for our new client is to set up an \"Audience\" mapper to set the audience claim in the token that our example app will check for.</p> <p>Navigate back to the \"Client details\" for our \"armasec_tutorial\" client and open the \"Client scopes\" tab. To add a new mapper for our client, click the link for \"armasec_tutorial-dedicated\" scope.</p> <p> Client Scopes</p> <p>The \"Mappers\" tab will load by default. Click the \"Configure a new mapper\" button.</p> <p> Configure Mapper</p> <p>Select the \"Audience\" mapper from the list that is shown.</p> <p> Select Audience</p> <p>The \"Add mapper\" form will be loaded next. In this form, name the mapper \"Audience\" and set the \"Included Custom Audience\" field to \"http://keycloak.local\". Make sure \"Add to ID token\" is selected. Finally, click \"Save\" to finish adding the new mapper.</p> <p> Mapper Settings</p> <p>The last step in configuring keycloak is setting up a user that will be accessing the protected endpoint.</p> <p>Navigate to the \"Users\" section using the side-nav and click the \"Add user\" button to get started.</p> <p> Add User</p> <p>In the \"Create user\" form that is opened next, name your user \"local-user\" and provide a fake email address like \"local-user@keycloak.local\". Click \"Create\" to create the new user.</p> <p> Create User</p> <p>Next, we need to assign the user a password that they will use to log in. Open the \"Credentials\" tab in the \"User details\" page for your new user. Click the \"Set password\" button.</p> <p> Set Password</p> <p>In the form that opens, use \"local\" for the password (and confirmation). Make sure to turn off the \"Temporary\" flag so that the user will not have to change their password in this tutoria. Then, click the \"Save\" button to finish setting up the user credentials.</p> <p> Save Password</p> <p>Next, we need to add the \"read:stuff\" role that we created before to your new user. Open the \"Role mapping\" tab in the \"User details\" page for your new user. Click the \"Assign role\" button.</p> <p> Assign Role</p> <p>In the \"Assign roles to local-user\" dialog that opens, click the drop down that shows \"Filter by realm roles\" and switch the setting to \"Filter by clients\". Find the \"read:stuff\" role that was assigned to the \"armasec_tutorial\" client, select it, and click the \"Assign\" button to assign this role to your new user.</p> <p> Select Role</p> <p>Now your client should be all set up and ready to go! Log out of the admin portal before you go on so that you are ready to log in with your new user later on in the tutorial.</p>"},{"location":"tutorials/getting_started_with_keycloak/#start-up-the-example-app","title":"Start up the example app","text":"example.py<pre><code>from armasec import Armasec\nfrom fastapi import FastAPI, Depends\napp = FastAPI()\narmasec = Armasec(\ndomain=\"localhost:8080/realms/master\",\naudience=\"http://keycloak.local\",\nuse_https=False,\npayload_claim_mapping=dict(permissions=\"resource_access.armasec_tutorial.roles\"),\ndebug_logger=print,\ndebug_exceptions=True,\n)\n@app.get(\"/stuff\", dependencies=[Depends(armasec.lockdown(\"read:stuff\"))])\nasync def check_access():\nreturn dict(message=\"Successfully authenticated!\")\n</code></pre> <p>Note in this example that the <code>use_https</code> flag must be set to false to allow a local server using unsecured HTTP.</p> <p>Also not that we need to add a <code>payload_claim_mapping</code> because Keycloak does not provide a permissions claim at the top level. This mapping copies the roles found at <code>resource_access.armasec_tutorial.roles</code> to a top-level attribute of the token payload called permissions.</p> <p>Copy the <code>example.py</code> app to a local source file called \"example.py\".</p> <p>Start it up with uvicorn:</p> <pre><code>python -m uvicorn --host 0.0.0.0 --port 5000 example:app\n</code></pre> <p>Once it is up and running, hit <code>&lt;ctrl-z&gt;</code> and type the command <code>bg</code> to put the uvicorn process into the background. You should make sure to kill the process when you complete the tutorial.</p>"},{"location":"tutorials/getting_started_with_keycloak/#login-via-armasec-cli","title":"Login via Armasec CLI","text":"<p>Next, you will log in using the Armasec CLI to get an API token to access your example API. Before you log in, however, you will need to configure the Armasec CLI to connect to your Keycloak server. Type the following command to configure the CLI:</p> <pre><code>armasec set-config --domain=localhost:8080/realms/master --audience=http://keycloak.local --no-use-https --client-id=armasec_tutorial\n</code></pre> <p>Now you should be ready to log in. In your terminal, type the following command to start the process:</p> <pre><code>armasec login\n</code></pre> <p>The CLI will show a box prompting you to complete the login process in a browser:</p> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Waiting for login \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                                         \u2502\n\u2502   To complete login, please open the following link in a browser:                                       \u2502\n\u2502                                                                                                         \u2502\n\u2502     http://localhost:8080/realms/master/device?user_code=TQOL-RIYP                                      \u2502\n\u2502                                                                                                         \u2502\n\u2502   Waiting up to 6.0 minutes for you to complete the process...                                          \u2502\n\u2502                                                                                                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nWaiting for web login... \u2578\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501   2% 0:04:56\n</code></pre> <p>Open the provided link in the browser and log in using the \"local-user\" that you created.</p> <p> Log in</p> <p>You will then be prompted with a question asking if you want to grant access. Click \"Yes\" to complete the log in process. The browser will show a message confirming that you are now logged in. You may close that browser tab.</p> <p>Notice in the terminal, a message is now printed showing that your user was logged in:</p> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Logged in! \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                                         \u2502\n\u2502   User was logged in with email 'local-user@keycloak.local'                                             \u2502\n\u2502                                                                                                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"tutorials/getting_started_with_keycloak/#fetch-the-auth-token","title":"Fetch the auth token","text":"<p>Next, you will use the Armasec CLI to fetch the token for the logged in user. To do this, you will use the <code>show-token</code> subcommand. In a terminal, type (the prefix flag includes the \"Bearer\" type indicator for the token):</p> <pre><code>armasec show-token --prefix\n</code></pre> <p>The Armasec CLI will print out a box showing the auth token for your user:</p> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Access Token \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                                         \u2502\n\u2502 Bearer                                                                                                  \u2502\n\u2502 eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJ3dzlNZ0FSNExXbXNuTE9vYTJKTkE4WXZkVUFZX25jZnNvcTU0c3d \u2502\n\u2502 kbERzIn0.eyJleHAiOjE3MDA1OTE2OTAsImlhdCI6MTcwMDU5MTYzMCwiYXV0aF90aW1lIjoxNzAwNTkxNjI4LCJqdGkiOiI0ZTNmN2 \u2502\n\u2502 U4Ni00ZTJhLTQwZDAtOWQ3ZS0zZTRmYjNkMzk1YWYiLCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjgwODAvcmVhbG1zL21hc3RlciIsI \u2502\n\u2502 mF1ZCI6WyJodHRwOi8va2V5Y2xvYWsubG9jYWwiLCJhY2NvdW50Il0sInN1YiI6IjMxMzY1ZWYyLTZmYjYtNGVhOS04MmE2LWUwMTli \u2502\n\u2502 YjYwNmFkOSIsInR5cCI6IkJlYXJlciIsImF6cCI6ImFybWFzZWNfdHV0b3JpYWwiLCJzZXNzaW9uX3N0YXRlIjoiYTc2ZWEzYTEtZGE \u2502\n\u2502 3MC00Mzg2LWFiZTMtZjFjZjYzZDI5ZjZhIiwiYWNyIjoiMSIsInJlYWxtX2FjY2VzcyI6eyJyb2xlcyI6WyJkZWZhdWx0LXJvbGVzLW \u2502\n\u2502 1hc3RlciIsIm9mZmxpbmVfYWNjZXNzIiwidW1hX2F1dGhvcml6YXRpb24iXX0sInJlc291cmNlX2FjY2VzcyI6eyJhcm1hc2VjX3R1d \u2502\n\u2502 G9yaWFsIjp7InJvbGVzIjpbInJlYWQ6c3R1ZmYiXX0sImFjY291bnQiOnsicm9sZXMiOlsibWFuYWdlLWFjY291bnQiLCJtYW5hZ2Ut \u2502\n\u2502 YWNjb3VudC1saW5rcyIsInZpZXctcHJvZmlsZSJdfX0sInNjb3BlIjoicHJvZmlsZSBlbWFpbCIsInNpZCI6ImE3NmVhM2ExLWRhNzA \u2502\n\u2502 tNDM4Ni1hYmUzLWYxY2Y2M2QyOWY2YSIsImVtYWlsX3ZlcmlmaWVkIjpmYWxzZSwicHJlZmVycmVkX3VzZXJuYW1lIjoibG9jYWwtdX \u2502\n\u2502 NlciIsImVtYWlsIjoibG9jYWwtdXNlckBrZXljbG9hay5sb2NhbCJ9.ntEA67CNS2ZvPIMac3X-1wKBTiKFS5i5aYo32M7ytVIrnh_X \u2502\n\u2502 j_YHLz17WmP3PBKyJtZKgIN8zq_nOF4XeRBMMHSg8ec9ySRNNRia0AkB0AKB-yPa4Q2qGwAFFipWhkP_iQapHj3XWPNDSVRPy8ZvRzb \u2502\n\u2502 LDjcgxhvSQE2Yzm68dtiVrcxA-FpImtJRNwARgeXFcvsYjrWfaACLVrvABgi0PiBiqPoFE4-zHEwhVZ3-DfmvXGRj4NxVsOzTyVkzi0 \u2502\n\u2502 pfMgHtOzI3MHb_hQ2xAtNBp-Ra5yYXHV3hteb_RPfjVTYADl6fq5Rggi3ydPsJVs0I7GAwzh85P8wRs127dtYv1w                \u2502\n\u2502                                                                                                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 The output was copied to your clipboard \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>If your terminal supports it, the token will be automatically copied into your clipboard. However, if you need to manually copy it, you can run the above command again with the <code>--plain</code> flag to print the token without formatting:</p> <pre><code>Bearer eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJ3dzlNZ0FSNExXbXNuTE9vYTJKTkE4WXZkVUFZX25jZnNvcTU0c3dkbERzIn0.eyJleHAiOjE3MDA1OTE2OTAsImlhdCI6MTcwMDU5MTYzMCwiYXV0aF90aW1lIjoxNzAwNTkxNjI4LCJqdGkiOiI0ZTNmN2U4Ni00ZTJhLTQwZDAtOWQ3ZS0zZTRmYjNkMzk1YWYiLCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjgwODAvcmVhbG1zL21hc3RlciIsImF1ZCI6WyJodHRwOi8va2V5Y2xvYWsubG9jYWwiLCJhY2NvdW50Il0sInN1YiI6IjMxMzY1ZWYyLTZmYjYtNGVhOS04MmE2LWUwMTliYjYwNmFkOSIsInR5cCI6IkJlYXJlciIsImF6cCI6ImFybWFzZWNfdHV0b3JpYWwiLCJzZXNzaW9uX3N0YXRlIjoiYTc2ZWEzYTEtZGE3MC00Mzg2LWFiZTMtZjFjZjYzZDI5ZjZhIiwiYWNyIjoiMSIsInJlYWxtX2FjY2VzcyI6eyJyb2xlcyI6WyJkZWZhdWx0LXJvbGVzLW1hc3RlciIsIm9mZmxpbmVfYWNjZXNzIiwidW1hX2F1dGhvcml6YXRpb24iXX0sInJlc291cmNlX2FjY2VzcyI6eyJhcm1hc2VjX3R1dG9yaWFsIjp7InJvbGVzIjpbInJlYWQ6c3R1ZmYiXX0sImFjY291bnQiOnsicm9sZXMiOlsibWFuYWdlLWFjY291bnQiLCJtYW5hZ2UtYWNjb3VudC1saW5rcyIsInZpZXctcHJvZmlsZSJdfX0sInNjb3BlIjoicHJvZmlsZSBlbWFpbCIsInNpZCI6ImE3NmVhM2ExLWRhNzAtNDM4Ni1hYmUzLWYxY2Y2M2QyOWY2YSIsImVtYWlsX3ZlcmlmaWVkIjpmYWxzZSwicHJlZmVycmVkX3VzZXJuYW1lIjoibG9jYWwtdXNlciIsImVtYWlsIjoibG9jYWwtdXNlckBrZXljbG9hay5sb2NhbCJ9.ntEA67CNS2ZvPIMac3X-1wKBTiKFS5i5aYo32M7ytVIrnh_Xj_YHLz17WmP3PBKyJtZKgIN8zq_nOF4XeRBMMHSg8ec9ySRNNRia0AkB0AKB-yPa4Q2qGwAFFipWhkP_iQapHj3XWPNDSVRPy8ZvRzbLDjcgxhvSQE2Yzm68dtiVrcxA-FpImtJRNwARgeXFcvsYjrWfaACLVrvABgi0PiBiqPoFE4-zHEwhVZ3-DfmvXGRj4NxVsOzTyVkzi0pfMgHtOzI3MHb_hQ2xAtNBp-Ra5yYXHV3hteb_RPfjVTYADl6fq5Rggi3ydPsJVs0I7GAwzh85P8wRs127dtYv1w\n</code></pre> <p>Keep the token close at hand; you will be using it shortly to access your API endpoint.</p>"},{"location":"tutorials/getting_started_with_keycloak/#try-it-out","title":"Try it out","text":"<p>Open a browser to localhost:8000/docs</p> <p> Swagger</p> <p>This will show you the auto-generated swagger docs for the example API app. Click on the <code>Authorize</code> button to add the token you copied to the clipboard in the header of requests to the API.</p> <p> Authorize</p> <p>First, paste the token (including the \"Bearer\" prefix) from the clipboard into the form and click the <code>Authorize</code> button in the dialog, click <code>Close</code> to dismiss the dialog. Now, all subsequent calls to the API will include a header that looks like:</p> <pre><code>{\n\"Authorization\": \"Bearer eyJhbGciOi...\"\n}\n</code></pre> <p>Now, expand the \"GET\" REST operation on the <code>/stuff</code> endpoint and click <code>Try it out</code>.</p> <p> Try it out</p> <p>Finally, click <code>Execute</code> to issue the request to the API.</p> <p> Execute</p> <p>You should see a response that includes a 200 status code and a response body that includes:</p> <pre><code>{\n\"message\": \"Successfully authenticated\"\n}\n</code></pre> <p>Congratulations! You are now using Armasec and Auth0 to authorize requests to your API.</p>"},{"location":"tutorials/getting_started_with_keycloak/#tinker","title":"Tinker","text":"<p>Now, there are a few things you can do to check out how things work. Try the following things:</p> <ul> <li>Remove the \"read:stuff\" role from your user and try another request</li> <li>Try a request without being authorized in swagger</li> <li>Try making requests using <code>curl</code> or the <code>httpx</code> library in IPython</li> </ul>"},{"location":"tutorials/getting_started_with_keycloak/#send-feedback","title":"Send feedback","text":"<p>If the above tutorial didn't work as expected, a step needs better clarification, or you have some questions about it, please create an issue on Armasec's GitHub's issues.</p>"}]}