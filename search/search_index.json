{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>An Omnivector initiative</p> <p></p>"},{"location":"#armasec-documentation","title":"Armasec Documentation","text":"<p>Armasec is a security package that simplifies OIDC security for FastAPI apps.</p>"},{"location":"#overview","title":"Overview","text":"<p>Adding a security layer on top of your API can be difficult, especially when working with an OIDC platform. It's hard enough to get your OIDC provider configured correctly. Armasec aims to take the pain out of securing your APIs routes.</p> <p>Armasec is an opinionated library that attemtps to use the most obvious and commonly used workflows when working with OIDC and making configuration as simple as possible.</p> <p>When using the Armasec helper class, you only need two configuration settings to get going:</p> <ol> <li>Domain: the domain of your OIDC provider</li> <li>Audience: An optional setting that restricts tokens to those intended for your API.</li> </ol> <p>That's it! Once you have those settings dialed in, you can just worry about checking the permissions scopes of your endpoints</p>"},{"location":"#inception","title":"Inception","text":"<p>Armasec was originally developed as an internal tool to add security in tandem with Auth0. Since its inception, Armasec has been used in production with both Auth0 and Keycloak. It should work with other OIDC providers, assuming they are configured correctly, but the developers of Armasec make no guarantees for other platforms.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> </ul>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>The <code>armasec</code> package can be installed like any other python package. It is available on PyPI</p>"},{"location":"getting_started/#poetry","title":"Poetry","text":"<p>To install via <code>poetry</code>, simply run:</p> <pre><code>poetry add armasec\n</code></pre>"},{"location":"getting_started/#pip","title":"Pip","text":"<p>To install directly with <code>pip</code>, simply run:</p> <pre><code>pip install armasec\n</code></pre>"},{"location":"minimal_example/","title":"Minimal Example","text":"<p>The following is a minimal example of how to configure your API to enforce security on endpoints using tokens issued by Auth0.</p> <p>First, create a file named <code>example.py</code> with the following contents:</p> example.py<pre><code>import os\nfrom armasec import Armasec\nfrom fastapi import FastAPI, Depends\napp = FastAPI()\narmasec = Armasec(\ndomain=os.environ.get(\"ARMASEC_DOMAIN\"),\naudience=os.environ.get(\"ARMASEC_AUDIENCE\"),\n)\n@app.get(\"/stuff\", dependencies=[Depends(armasec.lockdown(\"read:stuff\"))])\nasync def check_access():\nreturn dict(message=\"Successfully authenticated!\")\n</code></pre> <p>In this example, you would have set two environment variables for your project settings:</p> <ul> <li><code>ARMASEC_DOMAIN</code></li> <li>This would be your Auth0 domain</li> <li>Example: <code>my-auth.us.auth0.com</code></li> <li><code>ARMASEC_AUDIENCE</code></li> <li>You get this from your Auth0 API App</li> <li>Example: <code>https://my-api.my-domain.com</code></li> </ul> <p>When you run your app, access to the <code>/stuff</code> endpoint would be restricted to authenticated users whose access tokens carried the permission scope \"read:stuff\".</p> <p>For a step-by-step walk-through of how to set up Auth0 for the minimal example, see the \"Getting Started with Auth0\" page.</p> <p>The above code can be found in examples/basic.py.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#armasec.armasec","title":"armasec.armasec","text":"<p>This module defines the core Armasec class.</p>"},{"location":"reference/#armasec.armasec.Armasec","title":"Armasec","text":"<p>This is a factory class for TokenSecurity. It allows the machinery of armasec to be initialized correctly so that the factory method <code>lockdown</code> can initialize new instances of TokenSecurity to protect routes. It's not essential to use Armasec to secure routes, but it cuts down on the boilerplate necessary to do so.</p>"},{"location":"reference/#armasec.armasec.Armasec.__init__","title":"__init__","text":"<pre><code>__init__(domain_configs: Optional[List[DomainConfig]] = None, debug_logger: Optional[Callable[[str], None]] = noop, debug_exceptions: bool = False, **kargs: bool)\n</code></pre> <p>Stores initialization values for the TokenSecurity. All are passed through.</p> <p>Parameters:</p> Name Type Description Default <code>domain_configs</code> <code>Optional[List[DomainConfig]]</code> <p>List of domain configuration to authenticate the tokens against.</p> <code>None</code> <code>debug_logger</code> <code>Optional[Callable[[str], None]]</code> <p>A callable, that if provided, will allow debug logging. Should be               passed as a logger method like <code>logger.debug</code></p> <code>noop</code> <code>debug_exceptions</code> <code>bool</code> <p>If True, raise original exceptions. Should only be used in a testing               or debugging context.</p> <code>False</code> <code>kargs</code> <p>Arguments compatible to instantiate the DomainConfig model.</p> <code>{}</code>"},{"location":"reference/#armasec.armasec.Armasec.lockdown","title":"lockdown  <code>cached</code>","text":"<pre><code>lockdown(*scopes: str, permission_mode: PermissionMode = PermissionMode.ALL) -&gt; TokenSecurity\n</code></pre> <p>Initialize an instance of TokenSecurity to lockdown a route. Uses memoization to minimize the number of TokenSecurity instances initialized. Applies supplied permission_mode when checking token permssions against TokenSecurity scopes.</p> <p>Parameters:</p> Name Type Description Default <code>scopes</code> <code>str</code> <p>A list of scopes needed to access the endpoint.</p> <code>()</code> <code>permissions_mode</code> <p>If \"ALL\", all scopes listed are required for access. If \"SOME\", only one of the scopes listed are required for access.</p> required"},{"location":"reference/#armasec.armasec.Armasec.lockdown_all","title":"lockdown_all","text":"<pre><code>lockdown_all(*scopes: str) -&gt; TokenSecurity\n</code></pre> <p>Initialize an instance of TokenSecurity to lockdown a route. Uses memoization to minimize the number of TokenSecurity instances initialized. Requires all the scopes in the TokenSecurity instance to be included in the token permissions. This is just a wrapper around <code>lockdown()</code> with default permission_mode and is only included for symmetry.</p> <p>Parameters:</p> Name Type Description Default <code>scopes</code> <code>str</code> <p>A list of the scopes needed to access the endpoint. All are required.</p> <code>()</code>"},{"location":"reference/#armasec.armasec.Armasec.lockdown_some","title":"lockdown_some","text":"<pre><code>lockdown_some(*scopes: str) -&gt; TokenSecurity\n</code></pre> <p>Initialize an instance of TokenSecurity to lockdown a route. Uses memoization to minimize the number of TokenSecurity instances initialized. Requires at least one permission in the token to match a scope attached to the TokenSecurity instance.</p> <p>Parameters:</p> Name Type Description Default <code>scopes</code> <code>str</code> <p>A list of the scopes needed to access the endpoint. Only one is required.</p> <code>()</code>"},{"location":"reference/#armasec.exceptions","title":"armasec.exceptions","text":""},{"location":"reference/#armasec.exceptions.ArmasecError","title":"ArmasecError","text":"<p>             Bases: <code>Buzz</code></p> <p>A custom exception class used for checking conditions and handling other exceptions.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>int</code> <p>The HTTP status code indicated by the error. Set to 400.</p>"},{"location":"reference/#armasec.exceptions.AuthenticationError","title":"AuthenticationError","text":"<p>             Bases: <code>ArmasecError</code></p> <p>Indicates a failure to authenticate and decode jwt.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>int</code> <p>The HTTP status code indicated by the error. Set to 401.</p>"},{"location":"reference/#armasec.exceptions.AuthorizationError","title":"AuthorizationError","text":"<p>             Bases: <code>ArmasecError</code></p> <p>Indicates that the provided claims don't match the claims required for a protected endpoint.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>int</code> <p>The HTTP status code indicated by the error. Set to 403.</p>"},{"location":"reference/#armasec.exceptions.PayloadMappingError","title":"PayloadMappingError","text":"<p>             Bases: <code>ArmasecError</code></p> <p>Indicates that the configured payload_claim_mapping did not match a path in the token.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>int</code> <p>The HTTP status code indicated by the error. Set to 500.</p>"},{"location":"reference/#armasec.openid_config_loader","title":"armasec.openid_config_loader","text":"<p>This module provides the OpenidConfigLoader which is used to load openid-configuration data from an OIDC provider.</p>"},{"location":"reference/#armasec.openid_config_loader.OpenidConfigLoader","title":"OpenidConfigLoader","text":""},{"location":"reference/#armasec.openid_config_loader.OpenidConfigLoader.config","title":"config  <code>property</code>","text":"<pre><code>config: OpenidConfig\n</code></pre> <p>Retrive the openid config from an OIDC provider. Lazy loads the config so that API calls are deferred until the coniguration is needed.</p>"},{"location":"reference/#armasec.openid_config_loader.OpenidConfigLoader.jwks","title":"jwks  <code>property</code>","text":"<pre><code>jwks: JWKs\n</code></pre> <p>Retrives JWKs public keys from an OIDC provider. Lazy loads the jwks so that API calls are deferred until the jwks are needed.</p>"},{"location":"reference/#armasec.openid_config_loader.OpenidConfigLoader.__init__","title":"__init__","text":"<pre><code>__init__(domain: str, use_https: bool = True, debug_logger: Optional[Callable[..., None]] = None)\n</code></pre> <p>Initializes a base TokenManager.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <p>The secret key needed to decode a token</p> required <code>domain</code> <code>str</code> <p>The domain of the OIDC provider. This is to construct the            openid-configuration url</p> required <code>use_https</code> <code>bool</code> <p>If falsey, use <code>http</code> instead of <code>https</code> (the default).</p> <code>True</code> <code>debug_logger</code> <code>Optional[Callable[..., None]]</code> <p>A callable, that if provided, will allow debug logging. Should be passed            as a logger method like <code>logger.debug</code></p> <code>None</code>"},{"location":"reference/#armasec.openid_config_loader.OpenidConfigLoader.build_openid_config_url","title":"build_openid_config_url  <code>staticmethod</code>","text":"<pre><code>build_openid_config_url(domain: str, use_https: bool = True)\n</code></pre> <p>Builds a url for an openid configuration given a domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The domain of the OIDC provider for which to build a URL</p> required <code>use_https</code> <code>bool</code> <p>Use <code>https</code> for the URL by default. If falsey, use <code>http</code> instead.</p> <code>True</code>"},{"location":"reference/#armasec.pytest_extension","title":"armasec.pytest_extension","text":"<p>This module provides a pytest plugin for testing.</p>"},{"location":"reference/#armasec.pytest_extension.build_mock_openid_server","title":"build_mock_openid_server","text":"<pre><code>build_mock_openid_server(domain, openid_config, jwk, jwks_uri) -&gt; Callable[[str, OpenidConfig, JWK, str], _GeneratorContextManager]\n</code></pre> <p>Provide a fixture that returns a context manager that mocks opend-config routes.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <p>The domain of the openid server to mock.</p> required <code>openid_config</code> <p>The config to return from the mocked config route.</p> required <code>jwk</code> <p>The jwk to return from the mocked jwk route.</p> required <code>jwks_uri</code> <p>The URL of the jwks route to mock.</p> required <p>Returns:</p> Type Description <code>Callable[[str, OpenidConfig, JWK, str], _GeneratorContextManager]</code> <p>A context manager that, while active, mocks the openid routes needed by Armasec.</p>"},{"location":"reference/#armasec.pytest_extension.build_rs256_token","title":"build_rs256_token","text":"<pre><code>build_rs256_token(rs256_private_key, rs256_iss, rs256_sub, rs256_kid)\n</code></pre> <p>Provide a fixture that returns a helper method that can build a JWT.</p> <p>The JWT is signed with the private key provided by the rs256_private_key.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_private_key</code> <p>An implicit fixture parameter.</p> required <code>rs256_iss</code> <p>An implicit fixture parameter.</p> required <code>rs256_sub</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.mock_openid_server","title":"mock_openid_server","text":"<pre><code>mock_openid_server(rs256_domain, rs256_openid_config, rs256_jwk, rs256_jwks_uri)\n</code></pre> <p>Provide a fixture that mocks an openid server using the extension fixtures.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_domain</code> <p>An implicit fixture parameter.</p> required <code>rs256_openid_config</code> <p>An implicit fixture parameter.</p> required <code>rs256_jwk</code> <p>An implicit fixture parameter.</p> required <code>rs256_jwks_uri</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.rs256_domain","title":"rs256_domain","text":"<pre><code>rs256_domain()\n</code></pre> <p>Provide a fixture that returns a domain for use in other fixtures.</p> <p>The value here doesn't really have anything to do with an actual domain name.</p>"},{"location":"reference/#armasec.pytest_extension.rs256_domain_config","title":"rs256_domain_config","text":"<pre><code>rs256_domain_config(rs256_domain)\n</code></pre> <p>Provide a fixture that returns the DomainConfig model for the default rs256 domain.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_domain</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.rs256_iss","title":"rs256_iss","text":"<pre><code>rs256_iss(rs256_domain)\n</code></pre> <p>Provide a fixture that returns an issuer claim for use in other fixtures.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_domain</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.rs256_jwk","title":"rs256_jwk","text":"<pre><code>rs256_jwk(rs256_kid)\n</code></pre> <p>Provide a fixture that returns a JWK for use in other fixtures.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_kid</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.rs256_jwks_uri","title":"rs256_jwks_uri","text":"<pre><code>rs256_jwks_uri(rs256_domain)\n</code></pre> <p>Provide a fixture that returns a jwks uri for use in other fixtures.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_jwks_uri</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.rs256_kid","title":"rs256_kid","text":"<pre><code>rs256_kid()\n</code></pre> <p>Provide a fixture that returns a KID header value for use in other fixtures.</p>"},{"location":"reference/#armasec.pytest_extension.rs256_openid_config","title":"rs256_openid_config","text":"<pre><code>rs256_openid_config(rs256_iss, rs256_jwks_uri)\n</code></pre> <p>Provide a fixture that returns an openid configuration for use in other fixtures.</p> <p>Parameters:</p> Name Type Description Default <code>rs256_iss</code> <p>An implicit fixture parameter.</p> required <code>rs256_jwks_uri</code> <p>An implicit fixture parameter.</p> required"},{"location":"reference/#armasec.pytest_extension.rs256_private_key","title":"rs256_private_key","text":"<pre><code>rs256_private_key()\n</code></pre> <p>Provide a fixture that returns a pre-generated private key for RS256 hashing in other fixtures.</p>"},{"location":"reference/#armasec.pytest_extension.rs256_public_key","title":"rs256_public_key","text":"<pre><code>rs256_public_key()\n</code></pre> <p>Provide a fixture that returns a pre-generated public key for RS256 hashing in other fixtures.</p>"},{"location":"reference/#armasec.pytest_extension.rs256_sub","title":"rs256_sub","text":"<pre><code>rs256_sub()\n</code></pre> <p>Provide a fixture that returns a sum claim for use in other fixtures.</p>"},{"location":"reference/#armasec.token_decoder","title":"armasec.token_decoder","text":"<p>This module provides an abstract base class for algorithmic token decoders</p>"},{"location":"reference/#armasec.token_decoder.TokenDecoder","title":"TokenDecoder","text":"<p>Decoder class used to decode tokens given an algorithm and jwks.</p>"},{"location":"reference/#armasec.token_decoder.TokenDecoder.__init__","title":"__init__","text":"<pre><code>__init__(jwks: JWKs, algorithm: str = 'RS256', debug_logger: Callable[..., None] | None = None, decode_options_override: dict | None = None, payload_claim_mapping: dict | None = None)\n</code></pre> <p>Initializes a TokenDecoder.</p> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>str</code> <p>The algorithm to use for decoding. Defaults to RS256.</p> <code>'RS256'</code> <code>jwks</code> <code>JWKs</code> <p>JSON web keys object holding the public keys for decoding.</p> required <code>openid_config</code> <p>The openid_configuration needed for claims such as 'issuer'.</p> required <code>debug_logger</code> <code>Callable[..., None] | None</code> <p>A callable, that if provided, will allow debug logging. Should                      be passed as a logger method like <code>logger.debug</code></p> <code>None</code> <code>decode_options_override</code> <code>dict | None</code> <p>Options that can override the default behavior of the jwt                      decode method. For example, one can ignore token expiration by                      setting this to <code>{ \"verify_exp\": False }</code></p> <code>None</code> <code>payload_claim_mapping</code> <code>dict | None</code> <p>Optional mappings that are applied to map claims to top-level                      attribute of TokenPayload using a dict format of:</p> <pre><code>                 ```\n                 {\n                     \"top_level+attribute\": \"decoded.token.JMESPath\"\n                 }\n                 ```\n                 The values _must_ be a valid JMESPath.\n\n                 Consider this example:\n\n                 ```\n                 {\n                      \"permissions\": \"resource_access.default.roles\"\n                 }\n                 ```\n\n                 The above example would result in a TokenPayload like:\n\n                 ```\n                 TokenPayload(permissions=token[\"resource_access\"][\"default\"][\"roles\"])\n                 ```\n                 Raises a 500 if the path does not match\n</code></pre> <code>None</code>"},{"location":"reference/#armasec.token_decoder.TokenDecoder.decode","title":"decode","text":"<pre><code>decode(token: str, **claims: str) -&gt; TokenPayload\n</code></pre> <p>Decode a JWT into a TokenPayload while checking signatures and claims.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The token to decode.</p> required <code>claims</code> <p>Additional claims to verify in the token.</p> <code>{}</code>"},{"location":"reference/#armasec.token_decoder.TokenDecoder.get_decode_key","title":"get_decode_key","text":"<pre><code>get_decode_key(token: str) -&gt; dict\n</code></pre> <p>Search for a public keys within the JWKs that matches the incoming token.</p> <p>Compares the token's unverified header against available JWKs. Uses the matching JWK for the decode key.  Raise AuthenticationError if matching public key cannot be found.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The token to match against available JWKs.</p> required"},{"location":"reference/#armasec.token_manager","title":"armasec.token_manager","text":"<p>This module defines a TokenManager that can be used to extract token payloads from request headers.</p>"},{"location":"reference/#armasec.token_manager.TokenManager","title":"TokenManager","text":"<p>Handle auth via a TokenDecoder and manage extraction from request headers and serialization into TokenPayload instances.</p>"},{"location":"reference/#armasec.token_manager.TokenManager.__init__","title":"__init__","text":"<pre><code>__init__(openid_config: OpenidConfig, token_decoder: TokenDecoder, audience: Optional[str] = None, debug_logger: Optional[Callable[..., None]] = None, decode_options_override: Optional[dict] = None)\n</code></pre> <p>Initialize a base TokenManager.</p> <p>Parameters:</p> Name Type Description Default <code>openid_config</code> <code>OpenidConfig</code> <p>The openid_configuration needed for claims such as 'issuer'.</p> required <code>token_decoder</code> <code>TokenDecoder</code> <p>The decoder used to verify jwts</p> required <code>audience</code> <code>Optional[str]</code> <p>An optional audience to check in decoded tokens.</p> <code>None</code> <code>debug_logger</code> <code>Optional[Callable[..., None]]</code> <p>A callable, that if provided, will allow debug logging. Should                      be passed as a logger method like <code>logger.debug</code></p> <code>None</code> <code>decode_options_override</code> <code>Optional[dict]</code> <p>Options that can override the default behavior of the jwt                      decode method. For example, one can ignore token expiration by                      setting this to <code>{ \"verify_exp\": False }</code></p> <code>None</code>"},{"location":"reference/#armasec.token_manager.TokenManager.extract_token_payload","title":"extract_token_payload","text":"<pre><code>extract_token_payload(headers: Union[Headers, dict]) -&gt; TokenPayload\n</code></pre> <p>Retrieve a token from a request header and decode it into a TokenPayload.</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Union[Headers, dict]</code> <p>The headers from which to retrieve a JWT.</p> required"},{"location":"reference/#armasec.token_manager.TokenManager.unpack_token_from_header","title":"unpack_token_from_header","text":"<pre><code>unpack_token_from_header(headers: Union[Headers, dict]) -&gt; str\n</code></pre> <p>Unpack a JWT from a request header.</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Union[Headers, dict]</code> <p>The headers from which to unpack a JWT.</p> required"},{"location":"reference/#armasec.token_payload","title":"armasec.token_payload","text":"<p>This module defines a pydantic schema for the payload of a jwt.</p>"},{"location":"reference/#armasec.token_payload.TokenPayload","title":"TokenPayload","text":"<p>             Bases: <code>BaseModel</code></p> <p>A convenience class that can be used to access parts of a decoded jwt.</p> <p>Attributes:</p> Name Type Description <code>sub</code> <code>str</code> <p>The \"sub\" claim from a JWT.</p> <code>permissions</code> <code>List[str]</code> <p>The permissions claims extracted from a JWT.</p> <code>expire</code> <code>datetime</code> <p>The \"exp\" claim extracted from a JWT.</p> <code>client_id</code> <code>str</code> <p>The \"azp\" claim extracted from a JWT.</p>"},{"location":"reference/#armasec.token_payload.TokenPayload.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert a TokenPayload to the equivalent dictionary returned by <code>jwt.decode()</code>.</p>"},{"location":"reference/#armasec.token_security","title":"armasec.token_security","text":"<p>This module defines a TokenSecurity injectable that can be used enforce access on FastAPI routes.</p>"},{"location":"reference/#armasec.token_security.ManagerConfig","title":"ManagerConfig","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model class to represent a TokenManager instance and its domain configuration for easier mapping</p> <p>Attributes:</p> Name Type Description <code>manager</code> <code>TokenManager</code> <p>The TokenManager instance to use for decoding tokens.</p> <code>domain_config</code> <code>DomainConfig</code> <p>The DomainConfig for the openid server.</p>"},{"location":"reference/#armasec.token_security.PermissionMode","title":"PermissionMode","text":"<p>             Bases: <code>AutoNameEnum</code></p> <p>Endpoint permissions.</p> <p>Attributes:</p> Name Type Description <code>ALL</code> <p>Require all listed permissions.</p> <code>SOME</code> <p>Require at least one of the listed permissions.</p>"},{"location":"reference/#armasec.token_security.TokenSecurity","title":"TokenSecurity","text":"<p>             Bases: <code>APIKeyBase</code></p> <p>An injectable Security class that returns a TokenPayload when used with Depends().</p> <p>Attributes:</p> Name Type Description <code>manager</code> <code>Optional[TokenManager]</code> <p>The TokenManager to use for token validation and extraction.</p>"},{"location":"reference/#armasec.token_security.TokenSecurity.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(request: Request) -&gt; TokenPayload\n</code></pre> <p>This method is called by FastAPI's dependency injection system when a TokenSecurity instance is injected to a route endpoint via the Depends() method. Lazily loads the OIDC config, the TokenDecoder, and the TokenManager if they are not already initialized.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request to check for secure access.</p> required"},{"location":"reference/#armasec.token_security.TokenSecurity.__init__","title":"__init__","text":"<pre><code>__init__(domain_configs: List[DomainConfig], scopes: Optional[Iterable[str]] = None, permission_mode: PermissionMode = PermissionMode.ALL, debug_logger: Optional[Callable[..., None]] = None, debug_exceptions: bool = False)\n</code></pre> <p>Initializes the TokenSecurity instance.</p> <p>Parameters:</p> Name Type Description Default <code>domain_configs</code> <code>List[DomainConfig]</code> <p>List of domain configuration to authenticate the tokens against.</p> required <code>scopes</code> <code>Optional[Iterable[str]]</code> <p>Optional permissions scopes that should be checked</p> <code>None</code> <code>permission_mode</code> <code>PermissionMode</code> <p>The PermissionMode to apply in the protected route.</p> <code>ALL</code> <code>debug_logger</code> <code>Optional[Callable[..., None]]</code> <p>A callable, that if provided, will allow debug logging. Should be               passed as a logger method like <code>logger.debug</code></p> <code>None</code> <code>debug_exceptions</code> <code>bool</code> <p>If True, raise original exceptions. Should only be used in a testing               or debugging context.</p> <code>False</code>"},{"location":"reference/#armasec.utilities","title":"armasec.utilities","text":"<p>Provides some utility functions.</p>"},{"location":"reference/#armasec.utilities.log_error","title":"log_error","text":"<pre><code>log_error(logger: Callable[..., None], dep: DoExceptParams)\n</code></pre> <p>Logs an en error with the supplied message, a string representation of the error, and its traceback. If the logger supplied is noop, do nothing. Pass as a partial when using the Buzz <code>handle_errors</code> context manager::</p> <pre><code>with Buzz.handle_errors(\"Boom!\", do_except=partial(log_error, debug_logger)):\n    do_some_risky_stuff()\n</code></pre>"},{"location":"reference/#armasec.utilities.noop","title":"noop","text":"<pre><code>noop(*args, **kwargs)\n</code></pre> <p>This is a no-op function that...does nothing.</p>"},{"location":"reference/#armasec.schemas.armasec_config","title":"armasec.schemas.armasec_config","text":"<p>This module provides a pydantic schema describing Armasec's configuration parameters.</p>"},{"location":"reference/#armasec.schemas.armasec_config.DomainConfig","title":"DomainConfig","text":"<p>             Bases: <code>BaseModel</code></p> <p>This model provides a specification for the input domains to authenticate against. It expects the domain indeed and the audience to refer to.</p> <p>Attributes:</p> Name Type Description <code>domain</code> <code>str</code> <p>The OIDC domain from which resources are loaded.</p> <code>audience</code> <code>Optional[str]</code> <p>Optional designation of the token audience.</p> <code>algorithm</code> <code>str</code> <p>The Algorithm to use for decoding. Defaults to RS256.</p> <code>use_https</code> <code>bool</code> <p>If true, use <code>https</code> for URLs. Otherwise use <code>http</code></p> <code>match_keys</code> <code>Dict[str, Union[str, List[Any], Dict[Any, Any], Set[Any], bool, int, float]]</code> <p>Dictionary of k/v pairs to match in the token when decoding it.</p>"},{"location":"reference/#armasec.schemas.jwks","title":"armasec.schemas.jwks","text":"<p>This module provides pydantic schemas for JSON Web Keys.</p>"},{"location":"reference/#armasec.schemas.jwks.JWK","title":"JWK","text":"<p>             Bases: <code>BaseModel</code></p> <p>This Model provides a specification for the objects retrieved from JWK endpoints in OIDC providers. It also assists with validation and item access.</p> <p>Attributes:</p> Name Type Description <code>alg</code> <code>str</code> <p>The algorithm to use for hash validation.</p> <code>e</code> <code>str</code> <p>The exponent parameter to use in RS256 hashing</p> <code>kid</code> <code>str</code> <p>The \"kid\" claim to uniquely identify the key.</p> <code>kty</code> <code>str</code> <p>The \"kty\" claim to identify the type of the key.</p> <code>n</code> <code>str</code> <p>The modulus parameter to use in RS256 hashing.</p> <code>use</code> <code>Optional[str]</code> <p>The claim that identifies the intended use of the public key.</p> <code>x5c</code> <code>Optional[List[str]]</code> <p>The X.509 certificate chain parameter</p> <code>x5c</code> <code>Optional[List[str]]</code> <p>The X.509 certificate SHA-1 thumbprint parameter</p>"},{"location":"reference/#armasec.schemas.jwks.JWKs","title":"JWKs","text":"<p>             Bases: <code>BaseModel</code></p> <p>This Model provides a specification for the container object retrieved from JWK endpoints in OIDC providers. It also assists with validation and item access.</p> <p>Attributes:</p> Name Type Description <code>keys</code> <code>List[JWK]</code> <p>The list of JWKs contained within.</p>"},{"location":"reference/#armasec.schemas.openid_config","title":"armasec.schemas.openid_config","text":"<p>This module provides a pydantic schema describing openid-configuration data.</p>"},{"location":"reference/#armasec.schemas.openid_config.OpenidConfig","title":"OpenidConfig","text":"<p>             Bases: <code>BaseModel</code></p> <p>Provides a specification for the objects retrieved from openid_configuration endpoint of the OIDC providers. Only includes needed fields for supported Manager instances. Assists with validation and item access.</p> <p>Attributes:</p> Name Type Description <code>issuer</code> <code>AnyHttpUrl</code> <p>The URL of the issuer of the tokens.</p> <code>jwks_uri</code> <code>AnyHttpUrl</code> <p>The URI where JWKs can be foun don the OpenID server.</p>"},{"location":"tutorials/getting_started_with_auth0/","title":"Getting started with Auth0","text":"<p>This step-by-step walk-through will show you how to get an Auth0 account set up for use with the minimal example.</p> <p>You will need:</p> <ul> <li>Python 3.8+ installed</li> <li>Python packages <code>armasec</code> and <code>uvicorn</code> installed</li> </ul>"},{"location":"tutorials/getting_started_with_auth0/#create-auth0-account-tenant","title":"Create Auth0 account tenant","text":"<p>Navigate to Auth0's homepage, and click <code>Sign Up</code>.</p> <p>Create a new account (if you don't already have one). It doesn't really matter how you choose to sign up, but I used my google account.</p> <p> Create a personal account</p> <p>For this tutorial, just select a \"Personal\" account. You can come back and repeat the process for your company later if you need to.</p> <p>Select <code>I need advanced settings</code> so that you can choose your tenant name, and click <code>Next</code> to move on to tenant setup.</p> <p> Select tenant domain</p> <p>Select your tenant domain. For this tutorial, I will be using \"armasec-tutorial\". Choose your region and click <code>Create Account</code>. The full domain that I will use later is \"armasec-tutorial.us.auth0.com\".</p>"},{"location":"tutorials/getting_started_with_auth0/#add-your-api-application","title":"Add your API application","text":"<p>This will set up the Auth0 api endpoints that Auth0 will use to authenticate your users.</p> <p> Navigate to Applications &gt; APIs</p> <p>Click <code>Applications</code> -&gt; <code>APIs</code></p> <p> Create an API</p> <p>Click <code>Create API</code></p> <p> Fill out API form</p> <p>Fill out the form. The Name you choose doesn't matter, but for the tutorial, I used \"Armasec Tutorial\".  Choose a name for the identifier that makes sense, as this will be the \"Audience\" for your tutorial app. I chose \"https://armasec-tutorial.com\" for this tutorial.</p> <p>Leave the \"Signing Algorithm\" as \"RS256\". Armasec also supports HS256, but it is not preferred.</p> <p>Click <code>Create</code></p> <p> Enable RBAC Settings</p> <p>Go to the Settings tab and scroll down to the \"RBAC Settings\"</p> <p>Activate <code>Enable RBAC</code> and <code>Add Permissions</code> in the Access Token\".</p> <p>This will include permissions scopes to your users' access tokens.</p> <p>Click <code>Save</code></p>"},{"location":"tutorials/getting_started_with_auth0/#add-your-permissions","title":"Add your permissions","text":"<p>Next, we will add the permission for the minimal example.</p> <p> Add a permission</p> <p>Click on the <code>Permissions</code> tab and add the \"read:stuff\" permission.</p>"},{"location":"tutorials/getting_started_with_auth0/#grant-your-permission-to-the-test-app","title":"Grant your permission to the test app","text":"<p>Auth0 provides a \"Machine-to-Machine\" test app for verifying that log in will work. We will grant our \"read:stuff\" permission to tokens provided from this app.</p> <p> Navigate to Applications</p> <p>Navigate to <code>Applications</code> -&gt; <code>Applications</code></p> <p> Select tutorial test app</p> <p>Click on <code>Armasec Tutorial (Test Application)</code></p> <p> Add permission to test app</p> <p>Go to the APIs tab and click the drop-down. Select the \"read-stuff\" box in the \"Permissions\" box. Click <code>Update</code>.</p>"},{"location":"tutorials/getting_started_with_auth0/#start-up-the-example-app","title":"Start up the example app","text":"<p>Copy the example app to a local source file called \"example.py\".</p> <p>Start it up with uvicorn:</p> <pre><code>python -m uvicorn --host 0.0.0.0 example:app\n</code></pre>"},{"location":"tutorials/getting_started_with_auth0/#try-it-out","title":"Try it out","text":"<p>Next, we will try to use a test token to call our minimal example's endpoint.</p> <p>Navigate back to <code>Applications</code> -&gt; <code>APIs</code>, select the <code>Armasec Tutorial</code>, and go to the Test tab.</p> <p> Copy test access token</p> <p>Find the \"Response\" box. This contains a token that has been issued by your test application. Click the <code>Copy Token</code> button.</p> <p>Now, open a browser to \"localhost:8000/docs\"</p> <p> Swagger page for example</p> <p>This will show you the auto-generated swagger docs for the example API app. Click on the <code>Authorize</code> button to add the token you copied to the clipboard in the header of requests to the API.</p> <p> Add access token in Swagger</p> <p>First, type \"Bearer \" followed by pasting the token from the clipboard into the form and click the <code>Authorize</code> button in the dialog, click <code>Close</code> to dismiss the dialog. Now, all subsequent calls to the API will include a header that looks like:</p> <pre><code>{\n\"Authorization\": \"Bearer eyJhbGciOi...\"\n}\n</code></pre> <p>Now, expand the \"GET\" REST operation on the <code>/stuff</code> endpoint and click <code>Try it out</code>.</p> <p> Try it out</p> <p>Finally, click <code>Execute</code> to issue the request to the API.</p> <p> Execute</p> <p>You should see a response that includes a 200 status code and a response body that includes:</p> <pre><code>{\n\"message\": \"Successfully authenticated\"\n}\n</code></pre> <p>Congratulations! You are now using Armasec and Auth0 to authorize requests to your API.</p>"},{"location":"tutorials/getting_started_with_auth0/#tinker","title":"Tinker","text":"<p>Now, there are a few things you can do to check out how things work. Try the following things:</p> <ul> <li>Remove the \"read:stuff\" permission from the test application and try another request</li> <li>Try a request without being authorized in swagger</li> <li>Try making requests using <code>curl</code> or the <code>httpx</code> library in IPython</li> </ul>"},{"location":"tutorials/getting_started_with_auth0/#send-feedback","title":"Send feedback","text":"<p>If the above tutorial didn't work as expected, a step needs better clarification, or you have some questions about it, please create an issue on Armasec's GitHub's issues.</p>"},{"location":"tutorials/getting_started_with_keycloak/","title":"Getting started with Keycloak","text":"<p>This step-by-step walk-through will show you how to get your Keycloak server set up to work with the minimal example. For this tutorial, I am running Keycloak locally with Docker.</p> <p>You will need:</p> <ul> <li>Docker installed (or an existing Keycloak server)</li> <li>Python 3.8+ installed</li> <li>Python packages <code>armasec</code> and <code>uvicorn</code> installed</li> </ul>"},{"location":"tutorials/getting_started_with_keycloak/#start-your-keycloak-server","title":"Start your Keycloak server","text":"<p>If you want to try the example locally without an existing Keycloak server, you can start a new one using Docker with the following command:</p> <pre><code>docker run -p 8080:8080 -e KEYCLOAK_ADMIN=\"admin\" -e KEYCLOAK_ADMIN_PASSWORD=\"admin\" keycloak/keycloak:18.0.0 start-dev\n</code></pre> <p>This will start a server who's admin UI is available at localhost:8080.</p> <p>Open a browser and load the address <code>localhost:8080</code>. Then, click on the \"Administration Console\" to log in.</p> <p> Log-in to admin console</p> <p>The sign-in credentials for the admin account are:</p> Field Value Username admin Password admin <p>After you log in, you will load the \"Master\" realm.</p>"},{"location":"tutorials/getting_started_with_keycloak/#set-up-your-master-realm","title":"Set up your \"Master\" realm","text":"<p>First, we need to change the lifespan for tokens. By default they expire after 1 minute, but that's not so friendly for a tutorial, so we will lengthen the lifespan to 5 minutes.</p> <p>Go to the \"Tokens\" tab of your \"Master\" realm and set the \"Access Token Lifespan\" to 5 minutes.</p> <p> Ream settings</p> <p>Click \"Save\" at the bottom after you change the value. All of the rest of the settings can be left as they are.</p>"},{"location":"tutorials/getting_started_with_keycloak/#set-up-a-client","title":"Set up a client","text":"<p>We will need a client that is configured with our permissions. To do this, navigate to the \"Clients\" tab in the nav bar and click the \"Create\" button:</p> <p> Clients</p> <p>For this tutorial, we will use the name \"armasec_tutorial\". Click \"Save\" to create the new client.</p> <p> Create client</p> <p>Now we need to set the following values for the new client:</p> Field Value Access Type Confidential Service Accounts Enabled ON Valid Redirect URIs * <p>The service account produce a token using the client secret over an API request to Keycloak.</p> <p> Client settings</p> <p>Next, we need to save the \"Client Secret\" for later when we request a token. Navigate to the \"Credentials\" tab and copy the value found in the \"Secret\" field.</p> <p> Secrets</p> <p>Next, we need to create the \"Roles\" that Armasec uses for the \"permissions\" claim inside the tokens. Navigate to the \"Roles\" tab for the client and click the \"Add Role\" button.</p> <p> Add role</p> <p>Fill the \"Role Name\" field with \"read:stuff\". There's no need to add a description at this time. Click the \"Save\" button to add the role to the client.</p> <p> Save role</p> <p>Finally, we need to set up an \"Audience\" mapper to set the audience claim in the token that our example app will check for.</p> <p>Navigate back to the \"armasec_tutorial\" client and open the \"Mappers\" tab. Click the \"Create\" button to add a new mapper.</p> <p> Mappers</p> <p>Create a new mapper with the following settings:</p> Field Value Name audience Mapper Type Audience Included Custom Audience http://keycloak.local Add to ID token ON <p>Click \"Save\" to create the new mapper.</p> <p> Audience mapper</p> <p>Now, for the purposes of this tutorial, we will be getting a token via a request with a \"Service Account Role\". We need to add the role we created above to the \"Service Account Role\" so that the token issued later includes the needed permissions.</p> <p>Navigate to the \"Service Account Roles\" tab. Then, select \"armasec_tutorial\" for the \"Client Roles\" field. Select the \"read:stuff\" role and add it with the \"Add selected &gt;&gt;\" button.</p> <p> Add role</p> <p>Now your client should be all set up and ready to go.</p>"},{"location":"tutorials/getting_started_with_keycloak/#start-up-the-example-app","title":"Start up the example app","text":"example.py<pre><code>from armasec import Armasec\nfrom fastapi import FastAPI, Depends\napp = FastAPI()\narmasec = Armasec(\ndomain=\"localhost:8080/realms/master\",\naudience=\"http://keycloak.local\",\nuse_https=False,\npayload_claim_mapping=dict(permissions=\"resource_access.armasec_tutorial.roles\"),\ndebug_logger=print,\ndebug_exceptions=True,\n)\n@app.get(\"/stuff\", dependencies=[Depends(armasec.lockdown(\"read:stuff\"))])\nasync def check_access():\nreturn dict(message=\"Successfully authenticated!\")\n</code></pre> <p>Note in this example that the <code>use_https</code> flag must be set to false to allow a local server using unsecured HTTP.</p> <p>Also not that we need to add a <code>payload_claim_mapping</code> because Keycloak does not provide a permissions claim at the top level. This mapping copies the roles found at <code>resource_access.armasec_tutorial.roles</code> to a top-level attribute of the token payload called permissions.</p> <p>Copy the <code>example.py</code> app to a local source file called \"example.py\".</p> <p>Start it up with uvicorn (running in the background):</p> <pre><code>python -m uvicorn --host 0.0.0.0 example:app\n</code></pre> <p>Once it is up and running, hit <code>&lt;ctrl-z&gt;</code> and type the command <code>bg</code> to put the uvicorn process into the background. You should make sure to kill the process when you complete the tutorial.</p>"},{"location":"tutorials/getting_started_with_keycloak/#get-the-test-token","title":"Get the test token","text":"<p>We will use <code>curl</code> to get an example token to test out our route's security. You will need to replace <code>$CLIENT_SECRET</code> with the secret variable we noted earlier. Alternatively, you can set a shell variable with this value and use the command directly.</p> <pre><code>curl -d \"client_id=armasec_tutorial&amp;client_secret=$CLIENT_SECRET&amp;grant_type=client_credentials\" -X POST \"http://localhost:8080/realms/master/protocol/openid-connect/token\"\n</code></pre> <p>You should see a JSON blob printed out that includes an <code>access_token</code> attribute along with other metadata about the token.</p>"},{"location":"tutorials/getting_started_with_keycloak/#try-it-out","title":"Try it out","text":"<p>Open a browser to localhost:8000/docs</p> <p> Swagger</p> <p>This will show you the auto-generated swagger docs for the example API app. Click on the <code>Authorize</code> button to add the token you copied to the clipboard in the header of requests to the API.</p> <p> Authorize</p> <p>First, type \"Bearer \" followed by pasting the token from the clipboard into the form and click the <code>Authorize</code> button in the dialog, click <code>Close</code> to dismiss the dialog. Now, all subsequent calls to the API will include a header that looks like:</p> <pre><code>{\n\"Authorization\": \"Bearer eyJhbGciOi...\"\n}\n</code></pre> <p>Now, expand the \"GET\" REST operation on the <code>/stuff</code> endpoint and click <code>Try it out</code>.</p> <p> Try it out</p> <p>Finally, click <code>Execute</code> to issue the request to the API.</p> <p> Execute</p> <p>You should see a response that includes a 200 status code and a response body that includes:</p> <pre><code>{\n\"message\": \"Successfully authenticated\"\n}\n</code></pre> <p>Congratulations! You are now using Armasec and Auth0 to authorize requests to your API.</p>"},{"location":"tutorials/getting_started_with_keycloak/#tinker","title":"Tinker","text":"<p>Now, there are a few things you can do to check out how things work. Try the following things:</p> <ul> <li>Remove the \"read:stuff\" role from the Service Account and try another request</li> <li>Try a request without being authorized in swagger</li> <li>Try making requests using <code>curl</code> or the <code>httpx</code> library in IPython</li> </ul>"},{"location":"tutorials/getting_started_with_keycloak/#send-feedback","title":"Send feedback","text":"<p>If the above tutorial didn't work as expected, a step needs better clarification, or you have some questions about it, please create an issue on Armasec's GitHub's issues.</p>"}]}